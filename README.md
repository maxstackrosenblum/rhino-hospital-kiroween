<div align="center">

<img src="frontend/public/logo-full.png" alt="Hospital Management System" width="400"/>

# Hospital Management System: A Frankenstein Story

</div>

## ğŸƒ Try It Yourself!

**Live Demo:** [YouTube Link](https://youtu.be/NEFTtyJi_r8)

**Live Site:** [Frontend](https://rhino-hospital-kiroween.onrender.com/)

**Test Credentials:**

| Role | Username | Password |
|------|----------|----------|
| Doctor | `jekill` | `SendMails123@` |
| Nurse | `abby` | `SendMails123@` |
| Patient | `victor` | `SendMails123@` |

**Available Features:**
- ğŸ¥ Hospital administration and staff management
- ğŸ“… Appointment scheduling and calendar management
- ğŸ©º Patient blood pressure tracking and health reports
- ğŸ‘¥ Patient and doctor management
- ğŸ” Role-based access control

---

## The Frankenstein Experiment: Bringing Dead Code Back to Life

Like Dr. Frankenstein assembling his creation from disparate parts, this project demonstrates something both thrilling and practicalâ€”the resurrection and fusion of legacy applications into a single, living system.

### The Challenge: Three Applications, Three Technologies, One Vision

In the dark corners of every organization lie abandoned applicationsâ€”once vital, now obsolete. Different technologies, incompatible architectures, lost documentation. For this Kiroween experiment, we faced three such creatures:

**ğŸ¥ The Hospital Admin System** - https://github.com/highblix/hospitalmanagementvb6

**ğŸ“… The Appointment Manager** - https://github.com/erentnr/hospital-appointment

**ğŸ©º The Blood Pressure Reporter** - https://github.com/juliemoore/PatientBloodPressureReport


### The Mad Science: Extracting Life from Dead Code

This is where the experiment begins. Using rhino.ai, we performed digital necromancyâ€”extracting the living business logic from these dead applications:

**The Extraction Process:**
1. **Archaeological Discovery** - Fed the old codebases, documentation fragments, and user manuals into rhino.ai
2. **Logic Resurrection** - Rhino analyzed the disparate systems, identifying core business rules, data models, and workflows
3. **Unified Understanding** - Transformed three incompatible systems into three coherent business logic documents
4. **The Blueprint** - Created a specification for a new creature that combines the best parts of each

What emerged wasn't just documentationâ€”it was the *essence* of each application, freed from the constraints of its original technology. In Rhino, we generated User Stories based on the required business logic for the applications. They are available within the KiroInput/RhinoDocs/ folder of the repository.

We then split the initial functionality into 3 scopes so that we could work on them in parallel. These are the .txt files in the KiroInput/ folder, alongside a technical prompt for creating steering documents and design specs.

### The Assembly: Building the Monster with Kiro

With the extracted business logic in hand, we turned to Kiroâ€”our modern laboratory for bringing this Frankenstein creation to life. But this wasn't crude stitching and lightning bolts. This was *specification-driven reanimation*.

**The Creation Process:**

1. **The Specifications** - Transformed business logic into formal requirements and design documents. Each feature from the old applications was reimagined for the new system.

2. **The Architecture** - Designed a unified data model that could accommodate hospital administration, appointment scheduling, and patient monitoring in a single, coherent structure.

3. **The Implementation** - Used Kiro's task-based approach to systematically build each component, testing and verifying as we went.

4. **The Integration** - Wove together functionality from three separate applications into one living, breathing system.

The result? A modern application built on FastAPI, React, and PostgreSQLâ€”but containing the business logic and workflows from three legacy systems.

### âš¡ The Timeline: 4 Days. Seriously.

Here's the shocking part: **this entire system was built in four working days (9-5, Monday through Thursday) by a team of three developers.**

Not "four days of sprinting around the clock." Not "four days plus nights and weekends." Four normal business days.

Traditional legacy migration projects take months or years. Rewriting from scratch? Even longer. But with rhino.ai extracting the business logic and Kiro orchestrating the implementation, we compressed what would normally be a multi-month project into less than a standard work week.

**Monday: Extraction & Specification**
- Morning: Fed legacy codebases into rhino.ai
- Afternoon: Reviewed extracted business logic, created unified specifications in Kiro
- End of day: Complete specs ready for implementation

**Tuesday-Wednesday: Implementation**
- Built backend models, services, and API endpoints
- Developed frontend components and workflows
- Integrated all three legacy system functionalities
- Continuous testing and verification throughout

**Thursday: Polish & Deploy**
- Final integration testing across modules
- UI/UX refinements
- Deployment preparation
- Production deployment complete

### ğŸ¤ Team Collaboration: The Kiro Advantage

What made this speed possible wasn't just AIâ€”it was how Kiro enabled seamless team collaboration:

**Shared Specifications as Source of Truth**
- All three developers worked from the same formal specifications
- No ambiguity about requirements or design decisions
- Changes to specs automatically visible to entire team

**Parallel Development Without Conflicts**
- Developer 1: Backend models and database layer
- Developer 2: API endpoints and business logic
- Developer 3: Frontend components and integration
- Kiro's task-based approach meant clear boundaries and minimal merge conflicts

**Continuous Verification**
- Each developer could verify their work independently
- Property-based tests ensured business logic preservation
- Integration tests caught cross-module issues early

**Living Documentation**
- Specifications stayed in sync with implementation
- New team members could onboard by reading specs
- Every feature traced back to original business logic

**Async Collaboration**
- Team members in different time zones
- Kiro provided context and continuity across sessions
- Commit messages referenced spec tasks for traceability

The traditional bottlenecksâ€”meetings to clarify requirements, merge conflicts, integration issues, lost contextâ€”simply didn't happen. The specifications provided a shared mental model, and Kiro kept everyone aligned.

### It's Alive! The Unified System

What emerged from the laboratory isn't just a new applicationâ€”it's a demonstration of what's possible when you can extract and recombine business logic across technological boundaries:

**From the Hospital Admin System:**
- Staff management (receptionists, workers, medical staff)
- Role-based access control
- Administrative workflows

**From the Appointment Manager:**
- Appointment scheduling and calendar management
- Doctor availability tracking
- Patient appointment history

**From the Blood Pressure Reporter:**
- Patient vital sign tracking
- Blood pressure monitoring
- Health report generation

All three systems, once isolated and incompatible, now work together seamlessly in a modern tech stack.

### The Lesson: Legacy Doesn't Mean Lost

This Frankenstein experiment proves something important: the business logic in your legacy applications isn't deadâ€”it's just trapped. With the right tools:

- **rhino.ai extracts** the living logic from dead code
- **Kiro rebuilds** it in modern technologies  
- **Your team collaborates** efficiently with shared specifications
- **You deliver** in days, not months

No more "we can't migrate because we don't understand the old system." No more "the original developers are gone and the knowledge is lost." No more "this will take six months and half our budget."

The logic can be extracted, understood, and rebornâ€”and your team can work together seamlessly to make it happen.

**What normally takes months:**
- âŒ 2-3 months: Reverse engineering legacy systems
- âŒ 1-2 months: Writing technical specifications
- âŒ 3-4 months: Implementation and integration
- âŒ 1-2 months: Testing and bug fixes
- âŒ **Total: 7-11 months (or more)**

**What we actually did:**
- âœ… Monday: rhino.ai extraction + Kiro specifications
- âœ… Tuesday-Wednesday: Implementation with continuous verification
- âœ… Thursday: Testing, polish, and deployment
- âœ… **Total: 4 business days**

That's not a typo. Four days of normal 9-5 work. No crunch time. No all-nighters. No pizza-fueled coding marathons. Just structured, specification-driven development with AI assistance.

### Technical Architecture

The reanimated creature runs on modern, production-ready technologies:

**Backend:**
- FastAPI (Python) - Modern, fast web framework with automatic API documentation
- PostgreSQL - Robust relational database with full ACID compliance
- SQLAlchemy - Powerful ORM with type safety and migration support
- Alembic - Database migration management
- JWT Authentication - Secure, stateless authentication
- Pydantic - Runtime type validation and serialization

**Frontend:**
- React - Component-based UI with hooks
- TypeScript - Type-safe JavaScript for better developer experience
- Modern CSS - Responsive design with CSS variables for theming
- Fetch API - Clean, promise-based HTTP client

**Infrastructure:**
- Docker & Docker Compose - Containerized deployment
- Automated migrations - Database schema versioning
- Environment-based configuration - Secure secrets management

## Services

- **PostgreSQL**: Database on port 5432 (mapped to 5433 on host)
- **FastAPI**: Backend API on port 8000
- **React**: Frontend on port 3000

## Quick Start

```bash
# Start all services (first time - will run migrations automatically)
docker-compose up -d

# View logs
docker-compose logs -f

# Stop all services
docker-compose down

# Reset database (WARNING: deletes all data)
docker-compose down -v
docker-compose up -d
```

## First Time Setup

1. **Start the services**:
   ```bash
   docker-compose up -d
   ```

2. **Create an admin user**:
   ```bash
   # Register via the frontend at http://localhost:3000
   # Or use the API:
   curl -X POST http://localhost:8000/api/register \
     -H "Content-Type: application/json" \
     -d '{
       "email": "admin@hospital.com",
       "username": "admin",
       "password": "admin123",
       "first_name": "Admin",
       "last_name": "User"
     }'
   
   # Set admin role
   docker-compose exec db psql -U postgres -d appdb -c \
     "UPDATE users SET role = 'admin' WHERE username = 'admin';"
   ```

3. **Access the application**:
   - Frontend: http://localhost:3000
   - Login with your admin credentials

## Access

- Frontend: http://localhost:3000
- Backend API: http://localhost:8000
- API Docs: http://localhost:8000/docs
- PostgreSQL: localhost:5432

## Database Credentials

- User: postgres
- Password: postgres
- Database: appdb

## Email Configuration (Optional)

Password reset emails are optional. To enable:

1. Copy `.env.example` to `.env`
2. Add your SMTP credentials:
```env
SMTP_USER=your-email@gmail.com
SMTP_PASSWORD=your-app-password
```
3. Restart backend: `docker compose restart backend`

See `EMAIL_SETUP.md` for detailed instructions.

**Without email configured**: Reset tokens will be logged to console instead.

## The Assembled Features

### ğŸ¥ Hospital Administration (from the Admin System)
- Staff management for receptionists, workers, and medical personnel
- Role-based access control and permissions
- Administrative workflows and resource allocation
- Staff directory with search and filtering

### ğŸ“… Appointment Management (from the Appointment Manager)
- Appointment scheduling with doctor availability
- Calendar views and time slot management
- Patient appointment history and tracking
- Automated conflict detection

### ğŸ©º Patient Health Monitoring (from the Blood Pressure Reporter)
- Blood pressure tracking and vital sign monitoring
- Health report generation and history
- Patient medical records and profiles
- Trend analysis and alerts

### ğŸ” Unified Security (new integration layer)
- JWT-based authentication across all modules
- Role-based authorization (Admin, Doctor, Receptionist, Patient)
- Secure API endpoints with proper access control
- Password reset and account management

### ğŸ’» Modern User Experience (rebuilt from scratch)
- Responsive design for desktop and mobile
- Real-time form validation and error handling
- Intuitive navigation across all three legacy systems
- Unified interface that makes the seams invisible

## The Reanimation Process

This project demonstrates a revolutionary approach to legacy modernization:

### 1. Extract Business Logic with rhino.ai
Instead of reverse-engineering code manually, rhino.ai analyzes legacy applications and extracts:
- Core business rules and validation logic
- Data models and relationships
- Workflow patterns and user journeys
- Integration requirements

### 2. Specify the New System with Kiro
Transform extracted logic into formal specifications:
- **Requirements** - Clear acceptance criteria for each feature
- **Design** - Modern architecture that unifies disparate systems
- **Tasks** - Granular implementation steps with verification
- **Properties** - Correctness guarantees that preserve business logic

### 3. Build and Verify Systematically
Kiro implements the specifications with continuous verification:
- Type checking and linting
- Unit and integration tests
- Property-based testing to ensure business rules hold
- Automated testing of cross-system integrations

### 4. Deploy the Unified System
The result is a single, modern application that combines functionality from multiple legacy systemsâ€”without losing any of the original business logic.

## Project Structure

```
hospital-management-system/
â”œâ”€â”€ .kiro/                   # Kiro configuration and specs
â”‚   â”œâ”€â”€ specs/              # Feature specifications
â”‚   â”‚   â”œâ”€â”€ patient-doctor-management/
â”‚   â”‚   â”œâ”€â”€ staff-management/
â”‚   â”‚   â”œâ”€â”€ auto-profile-creation/
â”‚   â”‚   â”œâ”€â”€ mailersend-integration/
â”‚   â”‚   â”œâ”€â”€ user-creation-improvements/
â”‚   â”‚   â”œâ”€â”€ user-table-restructuring/
â”‚   â”‚   â””â”€â”€ vite-mui-migration/
â”‚   â””â”€â”€ steering/           # Development guidelines
â”‚       â”œâ”€â”€ project-context.md
â”‚       â”œâ”€â”€ coding-standards.md
â”‚       â”œâ”€â”€ git-workflow.md
â”‚       â”œâ”€â”€ database-guidelines.md
â”‚       â”œâ”€â”€ database-migrations.md
â”‚       â”œâ”€â”€ api-development.md
â”‚       â”œâ”€â”€ docker-commands.md
â”‚       â””â”€â”€ testing-guide.md
â”œâ”€â”€ backend/                # FastAPI backend
â”‚   â”œâ”€â”€ alembic/           # Database migrations
â”‚   â”œâ”€â”€ core/              # Core utilities and config
â”‚   â”œâ”€â”€ middleware/        # Custom middleware
â”‚   â”œâ”€â”€ repositories/      # Data access layer
â”‚   â”œâ”€â”€ services/          # Business logic layer
â”‚   â”œâ”€â”€ routers/           # API route handlers
â”‚   â”œâ”€â”€ tests/             # Test suite
â”‚   â”œâ”€â”€ models.py          # SQLAlchemy models
â”‚   â”œâ”€â”€ schemas.py         # Pydantic schemas
â”‚   â”œâ”€â”€ auth.py            # Authentication logic
â”‚   â”œâ”€â”€ database.py        # Database connection
â”‚   â””â”€â”€ main.py            # Application entry point
â”œâ”€â”€ frontend/              # React frontend with TypeScript
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ components/    # Reusable UI components
â”‚   â”‚   â”œâ”€â”€ pages/         # Page components
â”‚   â”‚   â”œâ”€â”€ hooks/         # Custom React hooks
â”‚   â”‚   â”œâ”€â”€ types/         # TypeScript type definitions
â”‚   â”‚   â””â”€â”€ App.tsx        # Main application component
â”‚   â”œâ”€â”€ public/            # Static assets
â”‚   â””â”€â”€ vite.config.js     # Vite configuration
â”œâ”€â”€ docs/                  # Documentation
â”‚   â”œâ”€â”€ architecture/      # System design documents
â”‚   â”‚   â”œâ”€â”€ HIPAA_COMPLIANCE.md
â”‚   â”‚   â”œâ”€â”€ INTERNATIONAL_COMPLIANCE.md
â”‚   â”‚   â”œâ”€â”€ SESSION_MANAGEMENT.md
â”‚   â”‚   â””â”€â”€ USER_ROLE_MANAGEMENT.md
â”‚   â”œâ”€â”€ features/          # Feature documentation
â”‚   â”‚   â”œâ”€â”€ APPOINTMENTS.md
â”‚   â”‚   â”œâ”€â”€ BLOOD_PRESSURE_MONITORING.md
â”‚   â”‚   â”œâ”€â”€ HOSPITALIZATIONS.md
â”‚   â”‚   â”œâ”€â”€ MEDICAL_STAFF_MANAGEMENT.md
â”‚   â”‚   â”œâ”€â”€ PATIENTS.md
â”‚   â”‚   â”œâ”€â”€ PRESCRIPTIONS.md
â”‚   â”‚   â”œâ”€â”€ SHIFTS.md
â”‚   â”‚   â””â”€â”€ PASSWORD_POLICY.md
â”‚   â””â”€â”€ setup/             # Setup and deployment guides
â”‚       â””â”€â”€ EMAIL_SETUP.md
â”œâ”€â”€ KiroInput/             # Original stakeholder documents
â”‚   â”œâ”€â”€ RhinoDocs/         # Rhino.ai generated user stories
â”‚   â”‚   â”œâ”€â”€ appointment-management-stories.pdf
â”‚   â”‚   â”œâ”€â”€ bloodpressure-report-stories.pdf
â”‚   â”‚   â””â”€â”€ hospital-admin-stories.pdf
â”‚   â”œâ”€â”€ Kiro-Technical-Prompt.txt
â”‚   â”œâ”€â”€ Person1-Patient-Doctor-Management.txt
â”‚   â”œâ”€â”€ Person2-Staff-Management.txt
â”‚   â””â”€â”€ Person3-Authentication-Access.txt
â”œâ”€â”€ docker-compose.yml     # Container orchestration
â””â”€â”€ README.md              # This file

```

## License

[MIT](https://choosealicense.com/licenses/mit/)

---

*Three legacy systems. Three developers. Four days. One living, breathing application.*

**Monday through Thursday. 9-5. No overtime. No crunch.**

**Built with rhino.ai extraction, Kiro collaboration, and a little mad science.** ğŸ§ªâš¡
